/* Polygenic quantitative simulation for the maintenance of variation
 (C) Nick O'Brien and OB Lab
 Here we consider a single trait evolving through time via drift and stabilising selection, until reaching 
 mutation-selection-drift balance. Genetic parameters/variables include mutation rate, population size, the nature of
 deleterious mutations (distribution of effects), recombination rate, number of QTLs, QTL distribution of effects,
 selection strength, and relative sizes of mutation rate hotspots/coldspots along the genome.
*/




// set up a simple neutral simulation
initialize() {
	if (!exists("slimgui")) {
		setCfgParam("seed", getSeed());
	}
	else {
		setSeed(asInteger(round(runif(1, 1, 2^62 - 1))));
		setCfgParam("seed", getSeed());
		catn("Actual seed: " + asInteger(seed));
	}
	
	
	// Declare/define parameters if they haven't been by the command line arguments
	// Values from literature are cited
	// The realistic range of w^2 is 3-50, so 18 to 5000 for 2w^2, or 0.05556 to 0.0002 for 1/2w^2
	setCfgParam("mu", 8.045e-6); // Mutation rate averaged across five species from Table 1 Aston et al. 2017 
	setCfgParam("Ne", 100); // Population size
	setCfgParam("del_mean", -0.8); // Mean used for the gamma distribution that deleterious mutations are pulled from
	setCfgParam("del_shape", 0.2); // Shape parameter for gamma distribution used for deleterious mutations
	setCfgParam("rwide", 1.241e-4); // Whole genome recombination rate
	setCfgParam("nloci", 100); // Number of QTL positions along the chromosome - where QTL mutations can appear, sampled from sample(): Fixed at 100
	setCfgParam("ndel", 100); // Number of deleterious sites 
	setCfgParam("genomelength", 500); // Loci across the genome - some are deleterious, others QTL, others neutral
	setCfgParam("locimu", 0.0); // Mean used for QTL mutation effect distribution pulls
	setCfgParam("locisigma", 1.0); // Variance used for QTL effect pulls - the additive effect size distribution
	setCfgParam("locidist", "n"); // Distribution used for locus distribution. "n" = normal, "g" = gamma
	setCfgParam("mu_props", c(0.05, 0.1, 0.5, 0.35)); // Relative chunk sizes of each mutation 'zone': zero, low, medium, high mutation rates - randomised across genome
	setCfgParam("width", 0.05556); // Width of the fitness curve: smaller = narrower curve, greater selection pressure: need to be careful with values, they need to be relative to the mean phenotype after burn-in, and the initial distance from the optimum. This should be precalculated as 1/2w^2, as in Lande 1976
	setCfgParam("opt", 10); // How far away optimum phenotype should be from mean phenotype post-burnin: Kingsolver et al. 2001 suggests .01 to 10 phenotypic units
	
	setCfgParam("outpositions", 'out_stabsel_pos.csv'); // Output filename/path for locus positions
	setCfgParam("outburn", 'out_stabsel_burnin.csv'); // Output burn-in heterozygosities
	setCfgParam("outname", 'out_stabsel_means.csv'); // Output filename/path for the trait means/variance
	setCfgParam("outopt", 'out_stabsel_opt.csv'); // Output filename/path for the trait optimum values for each run
	setCfgParam("outnamemuts", 'out_stabsel_muts.csv'); //Output filename/path for the mutation information
	
	
	setCfgParam("modelindex", 1); // Identifier for the combination of predictors used in latin hypercube: this is the row number in the lscombos.csv file
	
	initializeMutationRate(mu);
	
	
	
	initializeMutationType("m1", 0.5, "f", 0.0); // Neutral, non-trait-affecting mutations
	
	//m2 mutation type: deleterious/background selection
	initializeMutationType("m2", 0.5, "g", del_mean, del_shape);  // del_mean and del_shape are defined in the batch run script, or the cfg parameters
	m2.color = "red";
	
	//m3 mutation type: QTL mutation
	initializeMutationType("m3", 0.5, locidist, locimu, locisigma);
	// m3.convertToSubstitution = F;
	m3.color = "green";
	
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	
	// uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, genomelength);
	initializeRecombinationRate(1e-8);
}


// Function definitions

function (void) setCfgParam(s$ name, ifls value) {
// Automate defining constants for SLiMgui and slim command line

	if (!exists(name)) {
		defineConstant(name, value);
	}
}


function (void) calcPhenotype(o<Individual> inds, o<Substitution> fixed) {
// Calculate phenotypes for individuals based on their QTL effects - both segregating and substitutions

	sizem3 = size(fixed[fixed.mutationType == m3]);
	fixedfx = sizem3 ? sum(fixed[fixed.mutationType == m3].selectionCoeff) else 0.0;
	
	for (ind in inds) {
		muts = ind.genomes.mutationsOfType(m3);			// Get only trait effects
		mutscount = size(muts);
		
		phenotype = (mutscount ? sum(muts.selectionCoeff) else 0.0);
		phenotype = phenotype + fixedfx; // add fixed effects
		ind.setValue("phenotype", phenotype);
	}
}

function (void) calcFitness(o<Individual> inds) {
// Calculate fitness from phenotype. Make sure this is only called after CalcPhenotype() and after sim.setValue("optimum")!
	phenotypes = inds.getValue("phenotype"); 
	dists = phenotypes - sim.getValue("optimum");
	inds.fitnessScaling = 0.01 + exp(-(dists^2) * width); // Fitness function comes from Lande 1976: width is 1/2w^2
}


function (void) createMutMap(f proportions) {
	// Sample a specified amount of the genome for each constraint level, apply a mutation rate to them
	
	QTLmap = c(1:genomelength); // Initialise the map where we store our output

	mutRates = c(mu*0.01, mu*0.1, mu, mu*2);

	mutEnds = asInteger(mu_props*genomelength);

	// Construct an equal-length vector of rates to match to the QTLs
	
	mutShuf = repEach(mutRates, mutEnds);

	samples = sample(mutShuf, genomelength);  // Shuffle the rates
		
	
	sim.chromosome.setMutationRate(samples, QTLmap);
}

// create a population of 500 individuals
// Drosophila - deleterious mutation rate: Peter Keightley Eyre-Walker: with Ne estimate and genome size
// Good estimate of how many deleterious mutations occur per site and gen, and distribution of effects
1 {
	sim.addSubpop("p1", Ne);
	
	// Define locations of QTLs, deleterious loci, and neutral	 loci
	lengthvec = 0:(genomelength - 1);
	pos_QTL = sample(lengthvec, nloci); // Set the positions of our QTLs, from position 1 to the length of the chromosome;
	del_pool = setDifference(lengthvec, pos_QTL); // Make sure we don't resample a QTL position for del loci
	pos_del = sample(del_pool, ndel); // Set our deleterious loci positions
	
	sim.setValue("pos_QTL", pos_QTL); //store these positions in a sim value
	sim.setValue("pos_del", pos_del);
	
	posfile = paste(modelindex, asString(seed), nloci, pos_QTL, ndel, pos_del, sep = ","); // Output information on where the QTLs are, and the recombination structure of the genome
	
	writeFile(outpositions, posfile, append = T);

	// Calculate evolvability/mutation map
	// Number of genes matters - need to consider length of genome vs number of genes
	// Reflects networks: central nodes likely have to be 0, cause highly pleiotropic
	// silent substitution rate should reflect mu_d
	// Fatness of tail is the parameter - the types of mutation
	// ds is the outcome, the distribution of genes across conserved vs not is the parameter
	// plot trait evolution over time
	// Slightly neutral problem: under strictly neutral fixation = polymorphism of NS/S: MK test
	// with small pops, polymorphic NS are inflated
	// regulatory 
	
/*	
	// This code is for separate distinct chunks of mutation rates (no mixing)

	mutRates = c(mu*0.001, mu*0.01, mu*0.1, mu); // Example setup of different mutation rates
	
	mutEnds = c(mu_props*genomelength);
	for (i in seq(1, 3)) { // Don't need to do mutEnds[0], since it's already correct
		mutEnds[i] = mutEnds[i-1] + mutEnds[i];
	}
	mutEnds = asInteger(mutEnds);
	
	sim.chromosome.setMutationRate(mutRates, mutEnds);
	catn("Mutation rate end: " + mutEnds + "; Mutation rate: " + mutRates);

*/	

	// This code is for randomised mutation rates across the genome
	
	createMutMap(mu_props);

}

// Mutations individually have no direct fitness effect, fitness is calculated on a trait basis
fitness(m3) {
	return 1.0;
}


// When a mutation appears, need to check if it occurs at a QTL or deleterious locus and set the mutation type
mutation(m1) {
	if (any(mut.position == sim.getValue("pos_QTL"))) { // If the mutation falls in any of our defined QTL loci within a region 
		mut.setMutationType(m3);
		mut.setSelectionCoeff(sim.mutationTypes[2].drawSelectionCoefficient());

	}
	else {
		if (any(mut.position == sim.getValue("pos_del"))) {
			mut.setMutationType(m2);
			mut.setSelectionCoeff(sim.mutationTypes[1].drawSelectionCoefficient());

		}
	}
	return T;
}

// Burn-in period
1:50000 late() {
	if (sim.generation % 500 != 0) // Grab a sample every 500 generations
		return;
	inds = sim.subpopulations.individuals;
	meanH = paste(calcHeterozygosity(inds.genomes), sep=",");
	VA = paste(calcVA(inds, sim.mutationTypes[2]));	
	calcPhenotype(inds, sim.substitutions);
	phenomean = mean(inds.getValue("phenotype"));
	Bfile = paste(sim.generation, asString(seed), modelindex, meanH, VA, phenomean, sep=",");
	writeFile(outburn, Bfile, append = T);	
	
	// Set the optimum as a fixed distance from post-burn-in population phenotype mean
	if (sim.generation == 50000) {
		optimum = opt + phenomean;
		sim.setValue("optimum", optimum);
		OptFile = paste(asString(seed), modelindex, optimum, sep = ",");
		writeFile(outopt, OptFile);
	}

	
}



// Selection period

50001:150000 late() {
		
	// Calculate phenotypes + fitness, write output
	inds = sim.subpopulations.individuals;
	calcPhenotype(inds, sim.substitutions);
	calcFitness(inds);

	if (sim.generation % 500 == 0) { // Write output every 500 gens
		meanH = paste(calcHeterozygosity(p1.genomes), sep=",");
		VA = paste(calcVA(p1.individuals, sim.mutationTypes[2]));
		phenotypes = inds.getValue("phenotype");
		phenomean = mean(phenotypes);
		w = mean(inds.fitnessScaling);
		dist = mean(abs(phenotypes - sim.getValue("optimum"))); // Absolute values so that means aren't biased towards 0 by drift 
		Mfile = paste(sim.generation, asString(seed), modelindex, meanH, VA, phenomean, dist, w, sep=",");
		writeFile(outname, Mfile, append = T);
	}
	
	
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////////	
// Allelic output: outputting effect sizes, types, frequencies etc.
	// Every 25000 generations: we can do it more often probably, but testing required	
	if (sim.generation % 25000 != 0)
		return;
	
	
	// Store vectors of unique mutations, sorted by the generation in which they originated
	muts = sortBy(c(sim.mutations[sim.mutations.mutationType != m1]), "originGeneration");
	
	// same for substitutions
	subs = sortBy(c(sim.substitutions[sim.substitutions.mutationType != m1]), "originGeneration");
	
	// Set up an empty output to store all our mutations' information for this generation
	mutsLines = NULL;
		
	// Put information on these unique mutations into a separate mutations file	
	
	// Check if there are any substitutions, if not we need to fix the output lines	by not including the \n character at the end of the last mutation line. 
	// This is because writeFile() automatically adds a \n character, so we'd end up with an extra empty line if we do write that way
	
	for (mut in muts) {
		mutFreq = mean(sim.subpopulations.genomes.containsMutations(mut));
		mutType = mut.mutationType.id;
		mutValue = asString(mut.selectionCoeff);
		
		// Look into array operators to remove these if/else statements	
		
		if (size(subs)) {
			mutsLine = paste(sim.generation, asString(seed), modelindex, mutType, mut.id, mut.position, mut.originGeneration, mutValue, mutFreq, "N/A", "\n", sep = ",");
			mutsLines = c(mutsLines, mutsLine);
		}

		else {
			if (mut != muts[muts.size() - 1]) // If there are no substitutions and we're on the last mutation, add a new line character, otherwise don't
				mutsLine = paste(sim.generation, asString(seed), modelindex, mutType, mut.id, mut.position, mut.originGeneration, mutValue, mutFreq, "N/A", "\n", sep = ",");
			else
				mutsLine = paste(sim.generation, asString(seed), modelindex, mutType, mut.id, mut.position, mut.originGeneration, mutValue, mutFreq, "N/A", "", sep = ",");

			mutsLines = c(mutsLines, mutsLine);
		}
	}
	
	
	
	for (sub in subs) {
		subFreq = 1.0;
		subType = sub.mutationType.id;
		subValue = asString(sub.selectionCoeff);
		
		// Look into array operators to remove these if/else statements
		
		if (sub != subs[subs.size() - 1])
			subLine = paste(sim.generation, asString(seed), modelindex, subType, sub.id, sub.position, sub.originGeneration, subValue, subFreq, sub.fixationGeneration, "\n", sep = ",");
		else
			subLine = paste(sim.generation, asString(seed), modelindex, subType, sub.id, sub.position, sub.originGeneration, subValue, subFreq, sub.fixationGeneration, "", sep = ",");

		mutsLines = c(mutsLines, subLine); // Add substitutions to mutation output
	
	}
	
	mutsFile = paste(mutsLines, ""); // n.b. does \b exist in eidos? Would make it easier
	
	// Write the mutations file
	// Fail safe in case there are no mutations at some point and the for loop doesn't run
	if (exists('mutsLine'))
		writeFile(outnamemuts, mutsFile, append = T);
	
	
	
	
	// End simulation
	if (sim.generation == 150000)
		sim.simulationFinished();

	
}




